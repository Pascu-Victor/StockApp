using BankApi.Data;
using Common.Models;
using Microsoft.EntityFrameworkCore;

namespace BankApi.Repositories.Impl
{
    /// <summary>
    /// Repository for managing transactions in the application using Entity Framework Core.
    /// </summary>
    /// <remarks>
    /// Initializes a new instance of the <see cref="TransactionRepository"/> class.
    /// </remarks>
    /// <param name="context">The database context to use for data access.</param>
    public class TransactionRepository(ApiDbContext context) : ITransactionRepository
    {
        private readonly ApiDbContext _context = context ?? throw new ArgumentNullException(nameof(context));

        /// <summary>
        /// Gets the list of all transaction logs asynchronously.
        /// </summary>
        public async Task<List<TransactionLogTransaction>> getAllTransactions()
        {
            return await _context.TransactionLogTransactions.Include(t => t.Author).ToListAsync();
        }

        /// <summary>
        /// Retrieves a list of transactions that match the specified filter criteria.
        /// </summary>
        /// <param name="criteria">The filter criteria to apply.</param>
        /// <returns>A list of transactions matching the criteria.</returns>
        public async Task<List<TransactionLogTransaction>> GetByFilterCriteriaAsync(TransactionFilterCriteria criteria)
        {
            ArgumentNullException.ThrowIfNull(criteria);

            // Build the query dynamically based on the filter criteria
            IQueryable<TransactionLogTransaction> query = _context.TransactionLogTransactions.Include(t => t.Author);

            if (!string.IsNullOrEmpty(criteria.StockName))
            {
                query = query.Where(t => EF.Functions.Like(t.StockName, $"%{criteria.StockName}%"));
            }

            if (!string.IsNullOrEmpty(criteria.Type))
            {
                query = query.Where(t => t.Type.ToLower().Equals(criteria.Type.ToLower()));
            }

            if (criteria.MinTotalValue.HasValue)
            {
                query = query.Where(t => (t.Amount * t.PricePerStock) >= criteria.MinTotalValue.Value);
            }

            if (criteria.MaxTotalValue.HasValue)
            {
                query = query.Where(t => (t.Amount * t.PricePerStock) <= criteria.MaxTotalValue.Value);
            }

            if (criteria.StartDate.HasValue)
            {
                query = query.Where(t => t.Date >= criteria.StartDate.Value);
            }

            if (criteria.EndDate.HasValue)
            {
                query = query.Where(t => t.Date <= criteria.EndDate.Value);
            }

            return await query.ToListAsync();
        }

        /// <summary>
        /// Adds a new transaction to the repository.
        /// </summary>
        /// <param name="transaction">The transaction to add.</param>
        public async Task AddTransactionAsync(TransactionLogTransaction transaction)
        {
            ArgumentNullException.ThrowIfNull(transaction);

            // Ensure the stock exists before adding the transaction
            bool stockExists = await _context.BaseStocks.AnyAsync(s => s.Name == transaction.StockName);
            if (!stockExists)
            {
                throw new InvalidOperationException($"Stock with name '{transaction.StockName}' does not exist.");
            }

            // Ensure the transaction ID is not set by the caller
            transaction.Id = 0; // Reset the ID to ensure it is generated by the database

            // Attach the user reference to the context to avoid re-adding the user
            if (transaction.Author != null)
            {
                _context.Attach(transaction.Author);
            }

            // Add the transaction to the database
            await _context.TransactionLogTransactions.AddAsync(transaction);
            await _context.SaveChangesAsync();
        }
    }
}
